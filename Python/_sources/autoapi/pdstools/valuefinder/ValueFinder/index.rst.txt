:py:mod:`pdstools.valuefinder.ValueFinder`
==========================================

.. py:module:: pdstools.valuefinder.ValueFinder


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pdstools.valuefinder.ValueFinder.ValueFinder




.. py:class:: ValueFinder(path: Optional[str] = None, df: Optional[Union[pandas.DataFrame, polars.DataFrame, polars.LazyFrame]] = None, verbose: bool = True, import_strategy: Literal[eager, lazy] = 'eager', **kwargs)


   Class to analyze Value Finder datasets.

   Relies heavily on polars for faster reading and transformations.
   See https://pola-rs.github.io/polars/py-polars/html/index.html

   Requires either df or a path to be supplied,
   If a path is supplied, the 'filename' argument is optional.
   If path is given and no filename is, it will look for the most recent.

   :param path: Path to the ValueFinder data files
   :type path: Optional[str]
   :param df: Override to supply a dataframe instead of a file.
              Supports pandas or polars dataframes
   :type df: Optional[DataFrame]
   :param import_strategy: Whether to import the file fully to memory, or scan the file
                           When data fits into memory, 'eager' is typically more efficient
                           However, when data does not fit, the lazy methods typically allow
                           you to still use the data.
   :type import_strategy: Literal['eager', 'lazy'], default = 'eager'
   :param verbose: Whether to print out information during importing
   :type verbose: bool

   :keyword th: An optional keyword argument to override the propensity threshold
   :kwtype th: float
   :keyword filename: The name, or extended filepath, towards the file
   :kwtype filename: Optional[str]
   :keyword subset: Whether to select only a subset of columns.
                    Will speed up analysis and reduce unused information
   :kwtype subset: bool

   .. py:method:: save_data(path: str = '.') -> os.PathLike

      Cache the ValueFinder dataset to a file

      :param path: Where to place the file
      :type path: str

      :returns: The paths to the file
      :rtype: PathLike


   .. py:method:: getCustomerSummary(th: Optional[float] = None) -> polars.DataFrame

      Computes the summary of propensities for all customers

      :param th: The threshold to consider an action 'good'.
                 If a customer has actions with propensity above this,
                 the customer has at least one relevant action.
                 If not given, will default to 5th quantile.
      :type th: Optional[float]


   .. py:method:: getCountsPerStage(customersummary: Optional[polars.DataFrame] = None) -> polars.DataFrame

      Generates an aggregated view per stage.

      :param customersummary: Optional override of the customer summary,
                              which can be generated by getCustomerSummary().
      :type customersummary: Optional[pl.DataFrame]


   .. py:method:: getThFromQuantile(quantile: float) -> float

      Return the propensity threshold corresponding to a given quantile

      If the threshold is already in `self._thMap`, simply gets it from there
      Otherwise, computes the threshold and then adds it to the map.

      :param quantile: The quantile to get the threshold for
      :type quantile: float


   .. py:method:: getCountsPerThreshold(th, return_df=False) -> Optional[polars.LazyFrame]


   .. py:method:: addCountsForThresholdRange(start, stop, step, method=Literal['threshold, quantile']) -> None

      Adds the counts per stage for a range of quantiles or thresholds.

      Once computed, the values are added to `.countsPerThreshold` so we
      only need to compute each value once.

      :param start: The starting of the range
      :type start: float
      :param stop: The end of the range
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float
      :param method: Whether to get a range of thresholds directly or compute
                     the thresholds from their quantiles
      :type method: Literal["threshold", "quantile"]:


   .. py:method:: plotPropensityDistribution(sampledN: int = 10000) -> plotly.graph_objects.Figure

      Plots the distribution of the different propensities.

      For optimization reasons (storage for all points in a boxplot and
      time complexity for computing the distribution plot),
      we have to sample to a reasonable amount of data points.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPropensityThreshold(sampledN=10000, stage='Eligibility') -> plotly.graph_objects.Figure

      Plots the propensity threshold vs the different propensities.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPieCharts(start: float = None, stop: float = None, step: float = None, *, method: Literal[ValueFinder.plotPieCharts.threshold, quantile] = 'threshold', rounding: int = 3, th: Optional[float] = None) -> plotly.graph_objects.FigureWidget

      Plots pie charts showing the distribution of customers

      The pie charts each represent the fraction of customers with
      the color indicating whether they have sufficient relevant actions
      in that stage of the NBAD arbitration.

      If no values are provided for start, stop or step, the pie charts are
      shown using the default propensity threshold, as part of the Value Finder
      class.

      :param start: The starting of the range
      :type start: float
      :param stop: The end of the range
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float

      :keyword method: Whether the range is computed based on the threshold directly
                       or based on the quantile of the propensity
      :kwtype method: Literal['threshold', 'quantile'], default='threshold'
      :keyword rounding: The number of digits to round the values by
      :kwtype rounding: int
      :keyword th: Choose a specific propensity threshold to plot
      :kwtype th: Optional[float]


   .. py:method:: plotDistributionPerThreshold(start: float = None, stop: float = None, step: float = None, *, method: Literal[threshold, ValueFinder.plotDistributionPerThreshold.quantile] = 'threshold', rounding=3) -> plotly.graph_objects.FigureWidget

      Plots the distribution of customers per threshold, per stage.

      Based on the precomputed data in self.countsPerThreshold,
      this function will plot the distribution per stage.

      To add more data points between a given range,
      simply pass all three arguments to this function:
      start, stop and step.

      :param start: The starting of the range
      :type start: float
      :param stop: The end of the range
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float

      :keyword method: Whether the range is computed based on the threshold directly
                       or based on the quantile of the propensity
      :kwtype method: Literal['threshold', 'quantile'], default='threshold'
      :keyword rounding: The number of digits to round the values by
      :kwtype rounding: int


   .. py:method:: plotFunnelChart(level: str = 'Action', query=None, return_df=False)

      Plots the funnel of actions or issues per stage.

      :param level: Which element to plot:
                    - If 'Actions', plots the distribution of actions.
                    - If 'Issues', plots the distribution of issues
      :type level: str, default = 'Actions'



