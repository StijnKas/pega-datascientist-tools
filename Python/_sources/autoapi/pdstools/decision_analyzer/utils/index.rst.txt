pdstools.decision_analyzer.utils
================================

.. py:module:: pdstools.decision_analyzer.utils


Attributes
----------

.. autoapisummary::

   pdstools.decision_analyzer.utils.DecisionAnalyzer
   pdstools.decision_analyzer.utils.ExplainabilityExtract
   pdstools.decision_analyzer.utils.NBADScope_Mapping


Classes
-------

.. autoapisummary::

   pdstools.decision_analyzer.utils.TableConfig


Functions
---------

.. autoapisummary::

   pdstools.decision_analyzer.utils.parsePegaDateTimeFormats
   pdstools.decision_analyzer.utils.apply_filter
   pdstools.decision_analyzer.utils.filtered_action_counts
   pdstools.decision_analyzer.utils.area_under_curve
   pdstools.decision_analyzer.utils.gini_coefficient
   pdstools.decision_analyzer.utils.get_first_level_stats
   pdstools.decision_analyzer.utils.get_git_version_and_date
   pdstools.decision_analyzer.utils.find_lever_value
   pdstools.decision_analyzer.utils.determine_extract_type
   pdstools.decision_analyzer.utils.process
   pdstools.decision_analyzer.utils.get_table_definition
   pdstools.decision_analyzer.utils.get_schema


Module Contents
---------------

.. py:function:: parsePegaDateTimeFormats(timestampCol='SnapshotTime', timestamp_fmt: str = None, strict_conversion: bool = True)

   Parses Pega DateTime formats.

   Supports the two most commonly used formats:

   - "%Y-%m-%d %H:%M:%S"
   - "%Y%m%dT%H%M%S.%f %Z"

   If you want to parse a different timezone, then

   Removes timezones, and rounds to seconds, with a 'ns' time unit.

   :param timestampCol: The column to parse
   :type timestampCol: str, default = 'SnapshotTime'
   :param timestamp_fmt: An optional format to use rather than the default formats
   :type timestamp_fmt: str, default = None
   :param strict_conversion: Whether to error on incorrect parses or just return Null values
   :type strict_conversion: bool, default = True


.. py:data:: DecisionAnalyzer
   :type:  Dict[str, TableConfig]

.. py:data:: ExplainabilityExtract
   :type:  Dict[str, TableConfig]

.. py:class:: TableConfig

   Bases: :py:obj:`TypedDict`


   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: default
      :type:  bool


   .. py:attribute:: type
      :type:  Type[polars.DataType]


   .. py:attribute:: required
      :type:  bool


.. py:data:: NBADScope_Mapping

.. py:function:: apply_filter(df: polars.LazyFrame, filters: Optional[Union[polars.Expr, List[polars.Expr]]] = None)

   Apply a global set of filters. Kept outside of the DecisionData class as
   this is really more of a utility function, not bound to that class at all.


.. py:function:: filtered_action_counts(df: polars.LazyFrame, groupby_cols: list, propensityTH: float = None, priorityTH: float = None) -> polars.LazyFrame

   Returns a DataFrame with action counts filtered based on the given propensity and priority thresholds.

   :param df: The input dataframe.
   :type df: pl.LazyFrame
   :param groupby_cols: The list of column names to group by(["pxEngagementStage", "pxInteractionID"]).
   :type groupby_cols: list
   :param propensityTH: The propensity threshold.
   :type propensityTH: float
   :param priorityTH: The priority threshold.
   :type priorityTH: float

   :returns: A DataFrame with action counts filtered based on the given propensity and priority thresholds.
   :rtype: pl.LazyFrame


.. py:function:: area_under_curve(df: polars.DataFrame, col_x: str, col_y: str)

.. py:function:: gini_coefficient(df: polars.DataFrame, col_x: str, col_y: str)

.. py:function:: get_first_level_stats(interaction_data: polars.LazyFrame, filters: List[polars.Expr] = None)

   Returns some first level stats of a dataframe. Used to
   show effects of user data filters.


.. py:function:: get_git_version_and_date()

.. py:function:: find_lever_value(decision_data, action, target_win_percentage, win_rank, low=0, high=100, precision=0.01, ranking_stages=['Arbitration'])

   Binary search algorithm to find lever given a desired win percentage


.. py:function:: determine_extract_type(raw_data)

.. py:function:: process(df: polars.LazyFrame, table: Literal['decision_analyzer', 'explainability_extract'], subset: bool = True, include_cols: Optional[Iterable[str]] = None, drop_cols: Optional[Iterable[str]] = None, raise_on_unknown: bool = True) -> polars.LazyFrame

.. py:function:: get_table_definition(table: str)

.. py:function:: get_schema(df: polars.LazyFrame, table_definition: Dict[str, pdstools.decision_analyzer.table_definition.TableConfig], include_cols: Iterable[str], drop_cols: Iterable[str], subset: bool, raise_on_unknown: bool = True) -> Dict[str, Type[polars.DataType]]

